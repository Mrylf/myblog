{"meta":{"title":"shell blog","subtitle":"","description":"一个萌新分享自己仅存的技术的地方","author":"sheep","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2022-12-26T12:20:44.033Z","updated":"2022-12-26T12:20:44.033Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"About meHi,我是sheel 欢迎来到我的个人博客 他现在似乎不在呢…就让咱简单介绍下吧 - 平平无奇的大学生一枚 没有精通的 前端、python、Linux、MySQL，这些都会一点 联系方式： QQ邮箱：&#50;&#51;&#x36;&#52;&#x34;&#x38;&#x33;&#x30;&#55;&#x39;&#64;&#x71;&#x71;&#46;&#99;&#x6f;&#x6d;"},{"title":"所有分类","date":"2022-12-26T04:42:41.331Z","updated":"2022-12-26T04:42:41.331Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-12-26T04:42:57.130Z","updated":"2022-12-26T04:42:57.130Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"My friends","date":"2022-12-29T09:53:14.606Z","updated":"2022-12-29T09:53:14.606Z","comments":true,"path":"friends/index.html","permalink":"http://example.com/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"高度塌陷问题","slug":"高度塌陷问题","date":"2023-02-16T05:16:34.000Z","updated":"2023-02-16T05:41:34.919Z","comments":true,"path":"2023/02/16/高度塌陷问题/","link":"","permalink":"http://example.com/2023/02/16/%E9%AB%98%E5%BA%A6%E5%A1%8C%E9%99%B7%E9%97%AE%E9%A2%98/","excerpt":"","text":"前言 在浮动布局中，父元素的高度默认是被子元素撑开的，当子元素浮动后，其会从文档流中脱离。将会无法撑起父元素的高度，从而导致父元素的高度丢失。 父元素高度丢失后，其下的元素就会自动上移，从而导致页面的布局混乱。所以高度塌陷是浮动布局中比较常见的一个问题。 示例图： 两种解决办法 使用after伪类解决 - 给塌陷的父元素设置after伪类 - 因为after伪类的content为行内元素输出 如有特定需要，则要用display:block转换为块级元素 - 最重要的一点是要用clear:both来清除浮动 将元素的overflow设置为一个非visible的值 - 常用方式：为元素设置overflow:hidden 开启其的BFC，使其可以包含浮动元素","categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"}]},{"title":"MySQL常用命令","slug":"MySQL常用命令","date":"2023-01-09T02:06:14.000Z","updated":"2023-01-09T02:24:47.486Z","comments":true,"path":"2023/01/09/MySQL常用命令/","link":"","permalink":"http://example.com/2023/01/09/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"进行登录 123mysql -hlocalhost -P3306 -uroot -p# 或者mysql -uroot -p 查看MySQL相关信息 1status; 查看数据库 1show databases; 创建数据库 1create database 数据库名; 删除数据库 1drop database 数据库名; 使用某个数据库 1use 数据库名; 查看当前MySQL服务实例支持的字符序 1show collation; 查看当前MySQL服务实例使用的字符集 1show variables like &#x27;character%&#x27;; 查看当前MySQL服务实例支持的字符集、字符集默认的字符序以及字符集占用的最大字节长度等信息 1show character set; 查看数据库的相关信息 1show create database 数据库名; 修改密码 1set password for root@localhost = password(‘123’); 创建某字符集数据库 1create database 数据库名 default character set utf8 collate utf8_general_ci; 查看MySQL服务实例支持的存储引擎 1show engines; “临时地”将MySQL“当前会话的”存储引擎设置为MyISAM 1set default_storage_engine=MyISAM; 查看表 1show tables; 查看表结构 1describe tablename; 查看表内容 1select * from 表名; 查看数据库版本 1select version(); 查看服务器当前时间 1select current_time; 创建数据库 1CREATE DATABASE `数据库名` CHARACTER SET &#x27;utf8&#x27; COLLATE &#x27;utf8_general_ci&#x27;; 创建表 123456CREATE TABLE `表名` ( `id` int NOT NULL, `name` varchar(255) NOT NULL, ……, PRIMARY KEY (`主键名`)) engine =InnoDB default charset =utf8; 将服务器内存中的数据刷新到数据库文件中 1flush tables with read lock; 利用mysqldump转存数据库，进入bin目录后输入以下命令 1mysqldump -uroot -proot &gt; sheep.sql 查看生成的备份的sql文件 1dir 备份数据库 1234567891011# 查看当前二进制状态show master status;# 锁定数据库lock tables student read;# 导出数据select * into outfile ‘student.bat’ from student;# 备份后解锁unlock tables; 备份多个数据库 1mysqldump -uroot -proot --databases 数据库名1 数据库名2 &gt; sheep.sql 备份所有数据 1mysqldump -uroot -proot -all -databases &gt; all.sql 恢复数据 123456789# 为表增加一个写锁lock tables student write;load data infile ‘student.bak’ -&gt;replace into table student;load data low_priority infile ‘student.bak’ -&gt;replace into table student;# 解锁unlock tables; 在进入到MySQL后，创建一个数据库然后利用此数据库导入现有的sql文件 12# source后跟的是sql文件地址，注意要用反斜杠source E:\\\\sheep.sql; 使用load data 倒入数据 1load data local infile ‘E:\\sheep.txt’ into table student character set utf8; 更改字符集 1set character_set_database=utf8; 查看建表信息 1show create table 表名; 设置复合主键 1primary key (字段名1, 字段名2); 设置外键 1foreign key(子表的外键字段) references 父表的表名 (父表的主键的字段名); 复制一个表结构 1create table 新表名 select * from 源表; 删除字段 1alter table 表名 drop 字段名; 添加新字段 1alter table 表名 add 新字段名 新数据类型 新约束条件; 修改字段名（或者数据类型） 1alter table 表名 change 旧字段名 新字段名 新数据类型; 仅对字段的数据类型进行修改 1alter table 表名 modify 字段名 新数据类型; 修改数据库字符集 1alter database 数据库名 character set =utf8; 修改表的字符集 1alter table 表名 character set = utf8; 添加约束条件 1alter table 表名 add constraint 约束名 约束类型 (字段名); 添加外键 1alter table 子表的数据表名 add foreign key(子表的外键名称) references 父表的数据表名称 (父表的主键名称); 删除约束条件 1alter table 表名 drop primary key; 删除唯一性 1ALTER TABLE 表名 DROP INDEX 字段名; 删除表的外键约束 1alter table 表名 drop foreign key 约束名; 修改表名 1rename table 旧表名 to 新表名; 插入数据 1insert into 表名 [(字段列表)] values (值列表); 查询 1select 字段名1，字段名2，...，字段名n from 表名where 查询条件; 复合查询 1select 字段1，...，字段n from 表名where 查询条件1 and 查询条件2 and...and 查询条件n; 指定范围查询 1select 字段1...，字段n from 表名where 查询条件[not] between 开始值 and 结束值; 模糊查询 1select 字段 from 表 where 某字段 like 条件; 空值查询 1select * from 表名 where 字段名 is null; 使用聚合函数 1select COUNT()/SUM()/AVG()/MAX()/MIN() from 表名; 分组查询 1select 字段1，字段2 from 表名 group by 字段 having 条件语句; 查询结果显示前几行 1select * from 表名 limit 行数; 降序排序输出 1select * from 表名 order by 字段 desc; 内连接 1select 字段1，字段2…. from 表1 inner join 表2 on 表1和表2之间的连接条件; 左外连接查询 1select 字段列表 from 表1 left join 表2 on 表1和表2之间的连接条件; 右外连接查询 1select 字段 from 表1 right join 表2 on 表1和表2之间的连接条件; 使用exits关键字的子查询 1select 字段名 from 表名1 where exists (select 字段 from 表名2 where 条件); 使用in或者not in关键字的子查询 1select 字段名1 from 表名1 where 字段名2 in (select 字段2 from 表名2); 使用any 或者all进行子查询 1表达式 &gt; any(子查询)","categories":[{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"}],"tags":[{"name":"MySQL常用命令","slug":"MySQL常用命令","permalink":"http://example.com/tags/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"}]},{"title":"Docker安装","slug":"Docker安装","date":"2023-01-03T03:59:36.000Z","updated":"2023-01-03T04:00:26.681Z","comments":true,"path":"2023/01/03/Docker安装/","link":"","permalink":"http://example.com/2023/01/03/Docker%E5%AE%89%E8%A3%85/","excerpt":"","text":"CentOS Docker 安装使用官方安装脚本自动安装安装命令如下： 1curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 也可以使用国内 daocloud 一键安装命令： 1curl -sSL https://get.daocloud.io/docker | sh 手动安装卸载旧版本较旧的 Docker 版本称为 docker 或 docker-engine 。如果已安装这些程序，则需要卸载它们以及相关的依赖项。 12345678sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装 Docker Engine-Community使用 Docker 仓库进行安装在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，可以从仓库安装和更新 Docker。 设置仓库安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。 123sudo yum install -y yum-utils \\ device-mapper-persistent-data \\ lvm2 使用以下命令来设置稳定的仓库。 1234使用官方源地址（比较慢）sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 可以选择国内的一些源地址： 1234阿里云sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 1234清华大学源sudo yum-config-manager \\ --add-repo \\ https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo 安装 Docker Engine-Community安装最新版本的 Docker Engine-Community 和 containerd 1sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 要安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装： 列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。 123456yum list docker-ce --showduplicates | sort -rdocker-ce.x86_64 3:18.09.1-3.el7 docker-ce-stabledocker-ce.x86_64 3:18.09.0-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.1.ce-3.el7 docker-ce-stabledocker-ce.x86_64 18.06.0.ce-3.el7 docker-ce-stable 通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1 1sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io 启动 Docker1sudo systemctl start docker 通过运行 hello-world 镜像来验证是否正确安装了 Docker Engine-Community1sudo docker run hello-world 卸载 docker删除安装包： 1yum remove docker-ce 删除镜像、容器、配置文件等内容： 1rm -rf /var/lib/docker","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://example.com/categories/Docker%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"Docker简介","slug":"Docker简介","date":"2023-01-02T04:35:39.000Z","updated":"2023-01-02T05:13:24.514Z","comments":true,"path":"2023/01/02/Docker简介/","link":"","permalink":"http://example.com/2023/01/02/Docker%E7%AE%80%E4%BB%8B/","excerpt":"","text":"1.什么是容器容器可以看作是一个简易的沙箱,程序再沙箱中运行,可以不用在意外界环境,容器将外界和运行程序相隔离 2.为什么会出现docker在开发过程,您使用了一台笔记本开发应用程序,这时你的笔记本具有特定的环境,特定的一些配置,其他同事的电脑配置环境不同.您在开发项目之后需要其他同事进行部署实施,因为客户电脑配置或软件环境的不同,会出现安装不上的问题. 现在我们就需要使用到容器.Docker之所以发展如此迅速,也是因为再开发过程中对于程序移植的标准化解决方案————系统平滑移植,容器虚拟化技术 3.容器与传统虚拟技术一、相同: 都是对于程序的隔离和封装 二、不同： 容器只需要再当前系统中开辟一块用户空间,与当前操作系统的其他进程相隔离 传统虚拟机:(VMare)会创建完整的虚拟机出来,要运行应用程序,需要进行部署和依赖,此外还需要安装整个操作系统 4.什么是DockerDocker是基于Go语言实现的云开源项目 Docker的主要目标是”Build Ship and Run Any App AnyWhere”,也就是说通过对应用组件的封装,分发,部署,运行等生命周期的管理,使用户的APP及运行环境能够做到“一次镜像,处处运行” Linux容器技术的出现就解决了这样一个问题,而Docker就是再它的基础上发展过来的.将应用打包成镜像通过镜像成为运行再Docker容器上面的实例,而Docker容器再任何操作系统上都是一致的,这就实现了跨平台,跨服务器.只需要一次配置好环境,换到别的计算机上就可以一键部署,大大简化了操作 5.Docker的优点一、快速，一致地交付您的应用程序 Docker 允许开发人员使用自己提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。 二、响应式部署和扩展 Docker 是基于容器的平台，允许高度可移植的工作负载。 Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。 Docker 的可移植性和轻量级的特性，还可以让使用者轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。 三、在同一硬件上运行更多工作负载 Docker 轻巧快速。 它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此使用者可以利用更多的计算能力来实现业务目标。 Docker 非常适合于高密度环境以及中小型部署，而使用者可以用更少的资源做更多的事情。 6.Docker的应用场景 Web 应用的自动化打包和发布。 自动化测试和持续集成、发布。 在服务型环境中部署和调整数据库或其他的后台应用。 从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。","categories":[{"name":"Docker学习","slug":"Docker学习","permalink":"http://example.com/categories/Docker%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-12-25T03:56:25.237Z","updated":"2023-01-01T02:35:40.619Z","comments":true,"path":"2022/12/25/hello-world/","link":"","permalink":"http://example.com/2022/12/25/hello-world/","excerpt":"","text":"本来是想把这篇自带的文章删除的，后来想想还是算了，当留个纪念。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"author":"sheep"}],"categories":[{"name":"前端","slug":"前端","permalink":"http://example.com/categories/%E5%89%8D%E7%AB%AF/"},{"name":"MySQL","slug":"MySQL","permalink":"http://example.com/categories/MySQL/"},{"name":"Docker学习","slug":"Docker学习","permalink":"http://example.com/categories/Docker%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://example.com/tags/CSS/"},{"name":"MySQL常用命令","slug":"MySQL常用命令","permalink":"http://example.com/tags/MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"name":"Docker","slug":"Docker","permalink":"http://example.com/tags/Docker/"}]}